#!/bin/bash
#
# clad - Claude with Automatic credential Detection
#
# Selects the best available Claude credential based on rate limit usage,
# then launches Claude Code in dangerous mode.
#
# Usage:
#   clad              Launch Claude with the best available credential
#   clad --add=NAME   Add a new credential account
#   clad --help       Show help
#
# Credential priority:
#   1. Project-level "credential" setting in .claude/clad.json (if present)
#   2. Default ~/.claude/.credentials.json
#   3. All other ~/.claude/.credentials-*.json files
#
# Selection algorithm:
#   - Check preferred key first. If <99% used, keep it.
#   - If >=99%, cycle through remaining keys.
#   - First key found with <90% usage wins.
#   - If all >=90%, use the key with lowest usage.

set -euo pipefail

CLAUDE_DIR="$HOME/.claude"
DEFAULT_CREDS="$CLAUDE_DIR/.credentials.json"
ACTIVE_MARKER="$CLAUDE_DIR/.credentials-active"
CONFIG_FILE="$CLAUDE_DIR/.clad-config.json"
OAUTH_CLIENT_ID="9d1c250a-e61b-44d9-88ed-5944d1962f5e"
OAUTH_TOKEN_URL="https://platform.claude.com/v1/oauth/token"
API_BASE="https://api.anthropic.com/v1"

# ── Colors ──────────────────────────────────────────────────────────────────

GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

log()         { echo -e "  ${BLUE}▸${NC} $1"; }
log_success() { echo -e "  ${GREEN}✓${NC} $1"; }
log_warn()    { echo -e "  ${YELLOW}⚠${NC} $1"; }
log_error()   { echo -e "  ${RED}✗${NC} $1"; }
log_header()  { echo -e "\n${CYAN}${BOLD}── $1 ──${NC}"; }

# Verbose-only variants — silent when verbose is off
vlog()         { [ "$VERBOSE" = true ] && log "$1" || true; }
vlog_success() { [ "$VERBOSE" = true ] && log_success "$1" || true; }
vlog_warn()    { [ "$VERBOSE" = true ] && log_warn "$1" || true; }
vlog_header()  { [ "$VERBOSE" = true ] && log_header "$1" || true; }

# ── Config helpers ─────────────────────────────────────────────────────────

# Global config: ~/.claude/.clad-config.json (verbose setting)
# Project config: .claude/clad.json in cwd (trust setting)

PROJECT_CONFIG=".claude/clad.json"

# Ensure global config file exists with defaults
init_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo '{"verbose":true}' | jq . > "$CONFIG_FILE"
    fi
}

# Read a global config value (handles boolean false correctly)
config_get() {
    jq -r ".$1 | if . == null then empty else tostring end" "$CONFIG_FILE" 2>/dev/null
}

# Set a global config value
config_set() {
    local updated
    updated=$(jq --argjson v "$2" ".$1 = \$v" "$CONFIG_FILE")
    echo "$updated" > "$CONFIG_FILE"
}

# Read a project config value from .claude/clad.json in cwd
project_config_get() {
    if [ -f "$PROJECT_CONFIG" ]; then
        jq -r ".$1 | if . == null then empty else tostring end" "$PROJECT_CONFIG" 2>/dev/null
    fi
}

# Set a project config value in .claude/clad.json in cwd
project_config_set() {
    mkdir -p "$(dirname "$PROJECT_CONFIG")"
    if [ -f "$PROJECT_CONFIG" ]; then
        local updated
        updated=$(jq --argjson v "$2" ".$1 = \$v" "$PROJECT_CONFIG")
        echo "$updated" > "$PROJECT_CONFIG"
    else
        echo "{}" | jq --argjson v "$2" ".$1 = \$v" > "$PROJECT_CONFIG"
    fi
}

# Extract account name from a credential file path
cred_to_account() {
    basename "$1" | sed 's/^\.credentials-//; s/\.json$//'
}

init_config
VERBOSE=$(config_get verbose)
VERBOSE="${VERBOSE:-true}"

# ── Dependency check ────────────────────────────────────────────────────────

for cmd in jq curl claude; do
    if ! command -v "$cmd" &>/dev/null; then
        log_error "Required command '${BOLD}$cmd${NC}' not found"
        exit 1
    fi
done

# ── Help ────────────────────────────────────────────────────────────────────

show_help() {
    cat <<'HELP'
clad - Claude with Automatic credential Detection

Manages multiple Claude Max accounts, checks rate limit usage across all
of them, and launches Claude Code with the best available credential.

USAGE
  clad                  Launch Claude with the best available credential
  clad --add=NAME       Add a new credential account named NAME
  clad --login=NAME     Re-login to an existing credential account
  clad --link=NAME      Link current directory to prefer NAME's credential
  clad --trust          Enable --dangerously-skip-permissions for this directory
  clad --no-trust       Disable --dangerously-skip-permissions for this directory
  clad --verbose        Enable verbose startup output
  clad --quiet          Disable verbose startup output (show warnings only)
  clad --help           Show this help message

  Any extra arguments are passed through to Claude Code:
    clad --resume ID    Resume a Claude session with the best credential
    clad -p "prompt"    Run a one-shot prompt

HOW IT WORKS
  1. Discovers all credential files (~/.claude/.credentials-*.json)
  2. Syncs refreshed tokens from .credentials.json back to named files
  3. Refreshes expired tokens via OAuth (prompts login if refresh fails)
  4. Checks rate limit usage for each credential (5h + 7d windows)
  5. Selects the best key and copies it to .credentials.json
  6. Launches claude (with --dangerously-skip-permissions if directory is trusted)

ADDING ACCOUNTS
  clad --add=work

  This creates ~/.claude/.credentials-work.json, launches Claude so you
  can type /login and authenticate in the browser, then saves the token
  and starts a session with the new credential.

RE-LOGIN
  clad --login=work

  Re-authenticates an existing account. Use this when a credential is
  corrupted or pointing to the wrong account. Launches Claude so you
  can /login with the correct account, then overwrites the credential.

PER-PROJECT PREFERENCES
  clad --link=work

  Stores "work" as the preferred credential in .claude/clad.json for
  the current directory. When clad is run from that directory, it will
  prefer that credential (as long as it's under 99% usage).

TRUST MODE
  clad --trust            Enable dangerous mode for current directory
  clad --no-trust         Disable dangerous mode for current directory

  When trusted, clad passes --dangerously-skip-permissions to Claude.
  When untrusted, Claude launches in normal (permission-prompting) mode.
  Directories are untrusted by default. Setting is stored in .claude/clad.json.

VERBOSITY
  clad --verbose    Show full startup output (discovery, rate limits, etc.)
  clad --quiet      Show only warnings, errors, and launch info

  This setting persists in ~/.claude/.clad-config.json.

CREDENTIAL FILES
  ~/.claude/.credentials.json         Active credential (used by Claude)
  ~/.claude/.credentials-NAME.json    Named credential accounts
  ~/.claude/.clad-config.json         Global settings (verbose)
  .claude/clad.json                    Per-directory settings (trust, credential)

  These files are gitignored in the ~/.claude repo. Only the clad script
  itself is tracked.

RATE LIMIT WINDOWS
  Claude Max uses two rolling usage windows:
    5-hour window   Short-term burst capacity
    7-day window    Long-term sustained usage

  clad checks which window is the "binding" (most restrictive) limit and
  uses that for its selection decision.
HELP
}

# ── Login helper ───────────────────────────────────────────────────────────

# Shared login flow: backs up creds, launches Claude for /login, saves result.
# Args: $1 = account_name, $2 = cred_file
do_login() {
    local account_name="$1"
    local cred_file="$2"

    # Back up current credentials
    local backup_creds
    backup_creds=$(mktemp)
    cp "$DEFAULT_CREDS" "$backup_creds" 2>/dev/null || true

    # Remove credentials to force login flow
    rm -f "$DEFAULT_CREDS"

    log "Type ${BOLD}/login${NC} in Claude, complete browser auth, then ${BOLD}/exit${NC} to return here."
    echo ""

    claude --dangerously-skip-permissions || true

    if [ -f "$DEFAULT_CREDS" ]; then
        cp "$DEFAULT_CREDS" "$cred_file"
        log_success "Saved credential: $(basename "$cred_file")"
        echo ""

        # Launch a session with the new credential
        log_success "${BOLD}Launching Claude Code with ${account_name}${NC}"
        echo ""
        exec claude --dangerously-skip-permissions
    else
        log_error "Login did not produce credentials"

        # Restore backup
        if [ -f "$backup_creds" ]; then
            cp "$backup_creds" "$DEFAULT_CREDS"
        fi
        rm -f "$backup_creds"
        exit 1
    fi
}

# ── Add account ─────────────────────────────────────────────────────────────

add_account() {
    local account_name="$1"

    # Validate name: alphanumeric, hyphens, underscores only
    if [[ ! "$account_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        log_error "Invalid account name '${account_name}'. Use only letters, numbers, hyphens, underscores."
        exit 1
    fi

    local cred_file="$CLAUDE_DIR/.credentials-${account_name}.json"

    if [ -f "$cred_file" ]; then
        log_error "Credential file already exists: $(basename "$cred_file")"
        log "To re-login, use ${BOLD}clad --login=${account_name}${NC}"
        exit 1
    fi

    log_header "Adding account: $account_name"
    do_login "$account_name" "$cred_file"
}

# ── Re-login account ──────────────────────────────────────────────────────

login_account() {
    local account_name="$1"

    # Validate name: alphanumeric, hyphens, underscores only
    if [[ ! "$account_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        log_error "Invalid account name '${account_name}'. Use only letters, numbers, hyphens, underscores."
        exit 1
    fi

    local cred_file="$CLAUDE_DIR/.credentials-${account_name}.json"

    if [ ! -f "$cred_file" ]; then
        log_error "No credential file for '${account_name}'"
        log "To create it, use ${BOLD}clad --add=${account_name}${NC}"
        exit 1
    fi

    log_header "Re-login: $account_name"
    log_warn "This will overwrite $(basename "$cred_file")"
    do_login "$account_name" "$cred_file"
}

# ── Link account ───────────────────────────────────────────────────────────

link_account() {
    local account_name="$1"

    # Validate name: alphanumeric, hyphens, underscores only
    if [[ ! "$account_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        log_error "Invalid account name '${account_name}'. Use only letters, numbers, hyphens, underscores."
        exit 1
    fi

    local cred_file="$CLAUDE_DIR/.credentials-${account_name}.json"

    if [ ! -f "$cred_file" ]; then
        log_error "No credential file for '${account_name}'"
        log "To create it, use ${BOLD}clad --add=${account_name}${NC}"
        exit 1
    fi

    project_config_set credential "\"$account_name\""
    log_success "Set preferred credential → ${BOLD}${account_name}${NC}"
    log "clad will prefer ${BOLD}${account_name}${NC} when run from $(pwd)"
    exit 0
}

# ── Trust toggle ───────────────────────────────────────────────────────────

set_trust() {
    local trust_val="$1"

    project_config_set trust "$trust_val"

    if [ "$trust_val" = "true" ]; then
        log_success "Trusted → ${BOLD}$(pwd)${NC} ${DIM}(dangerous mode enabled)${NC}"
    else
        log_success "Untrusted → ${BOLD}$(pwd)${NC} ${DIM}(permission prompts enabled)${NC}"
    fi
    exit 0
}

# ── Parse arguments ─────────────────────────────────────────────────────────

# Separate clad-specific flags from args to pass through to claude
CLAUDE_ARGS=()
for arg in "$@"; do
    case "$arg" in
        --help|-h)
            show_help
            exit 0
            ;;
        --add=*)
            add_account "${arg#--add=}"
            ;;
        --login=*)
            login_account "${arg#--login=}"
            ;;
        --link=*)
            link_account "${arg#--link=}"
            ;;
        --trust)
            set_trust true
            ;;
        --no-trust)
            set_trust false
            ;;
        --verbose)
            config_set verbose true
            log_success "Verbose output enabled"
            exit 0
            ;;
        --quiet)
            config_set verbose false
            log_success "Verbose output disabled"
            exit 0
            ;;
        *)
            CLAUDE_ARGS+=("$arg")
            ;;
    esac
done

# ── Helper: check if a credential's access token is expired ─────────────────

is_token_expired() {
    local cred_file="$1"
    local expires_at now_ms
    expires_at=$(jq -r '.claudeAiOauth.expiresAt // 0' "$cred_file" 2>/dev/null)
    now_ms=$(( $(date +%s) * 1000 ))
    [ "$expires_at" -gt 0 ] 2>/dev/null && [ "$expires_at" -lt "$now_ms" ] 2>/dev/null
}

# ── Helper: get the friendly label for a credential file ────────────────────

cred_label() {
    local cred_file="$1"
    local name tier
    name=$(basename "$cred_file")
    tier=$(jq -r '.claudeAiOauth.rateLimitTier // "unknown"' "$cred_file" 2>/dev/null)
    echo "$name ${DIM}($tier)${NC}"
}

# ── Token refresh ───────────────────────────────────────────────────────────

# Refreshes an expired OAuth token via the refresh_token grant.
# Updates the credential file in place. Returns 0 on success, 1 on failure.
refresh_token() {
    local cred_file="$1"
    local refresh_tok
    refresh_tok=$(jq -r '.claudeAiOauth.refreshToken // empty' "$cred_file" 2>/dev/null)

    if [ -z "$refresh_tok" ]; then
        return 1
    fi

    local response
    response=$(curl -s -X POST "$OAUTH_TOKEN_URL" \
        -H "Content-Type: application/json" \
        -d "{\"grant_type\":\"refresh_token\",\"refresh_token\":\"$refresh_tok\",\"client_id\":\"$OAUTH_CLIENT_ID\"}" \
        2>/dev/null) || return 1

    # Check for error response
    local err_type err_msg
    err_type=$(echo "$response" | jq -r '.error // empty' 2>/dev/null)
    err_msg=$(echo "$response" | jq -r '.error_description // .message // empty' 2>/dev/null)
    if [ -n "$err_type" ]; then
        log_error "  Refresh error: ${err_type}${err_msg:+ — $err_msg}"
        return 1
    fi

    # Empty or non-JSON response
    if [ -z "$response" ] || ! echo "$response" | jq -e '.' &>/dev/null; then
        log_error "  Refresh returned invalid response"
        return 1
    fi

    # Extract new tokens
    local new_access new_refresh expires_in
    new_access=$(echo "$response" | jq -r '.access_token // empty')
    new_refresh=$(echo "$response" | jq -r '.refresh_token // empty')
    expires_in=$(echo "$response" | jq -r '.expires_in // 0')

    if [ -z "$new_access" ] || [ -z "$new_refresh" ]; then
        return 1
    fi

    # Calculate expiresAt in milliseconds
    local now_ms expires_at
    now_ms=$(( $(date +%s) * 1000 ))
    expires_at=$(( now_ms + (expires_in * 1000) ))

    # Update the credential file, preserving all other fields
    local updated
    updated=$(jq \
        --arg at "$new_access" \
        --arg rt "$new_refresh" \
        --argjson ea "$expires_at" \
        '.claudeAiOauth.accessToken = $at | .claudeAiOauth.refreshToken = $rt | .claudeAiOauth.expiresAt = $ea' \
        "$cred_file")

    echo "$updated" > "$cred_file"
    return 0
}

# ── Step 1: Discover credential files ───────────────────────────────────────

vlog_header "Discovering credentials"

CRED_FILES=()
for f in "$CLAUDE_DIR"/.credentials-*.json; do
    [ -f "$f" ] && CRED_FILES+=("$f")
done

if [ ${#CRED_FILES[@]} -eq 0 ]; then
    log_warn "No credential files found. Add one with: ${BOLD}clad --add=NAME${NC}"
    log "Launching with default credentials..."
    exec claude --dangerously-skip-permissions "${CLAUDE_ARGS[@]}"
fi

for f in "${CRED_FILES[@]}"; do
    vlog "Found $(cred_label "$f")"
done

# ── Step 2: Sync back refreshed tokens from .credentials.json ───────────────

# Claude Code refreshes the token in .credentials.json on launch, but the
# named credential files become stale. Use the active marker (written in Step 7)
# to know which named file was last activated, and sync only to that file.
if [ -f "$DEFAULT_CREDS" ] && [ -f "$ACTIVE_MARKER" ]; then
    active_file=$(cat "$ACTIVE_MARKER" 2>/dev/null)
    if [ -n "$active_file" ] && [ -f "$active_file" ]; then
        default_expires=$(jq -r '.claudeAiOauth.expiresAt // 0' "$DEFAULT_CREDS" 2>/dev/null)
        active_expires=$(jq -r '.claudeAiOauth.expiresAt // 0' "$active_file" 2>/dev/null)

        if [ "$default_expires" -gt "$active_expires" ] 2>/dev/null; then
            cp "$DEFAULT_CREDS" "$active_file"
            vlog_success "Synced refreshed token → $(basename "$active_file")"
        fi
    fi
fi

# ── Step 3: Refresh expired tokens ─────────────────────────────────────────

STALE_CREDS=()

for f in "${CRED_FILES[@]}"; do
    if is_token_expired "$f"; then
        vlog "$(basename "$f") expired, attempting refresh..."
        if refresh_token "$f"; then
            vlog_success "  Refreshed successfully"
        else
            STALE_CREDS+=("$f")
        fi
    fi
done

# ── Step 4: Interactive login for irrecoverable tokens ──────────────────────

if [ ${#STALE_CREDS[@]} -gt 0 ]; then
    log_header "Credentials need re-login"

    for f in "${STALE_CREDS[@]}"; do
        tier=$(jq -r '.claudeAiOauth.rateLimitTier // "unknown"' "$f" 2>/dev/null)
        log_warn "$(basename "$f") ${DIM}($tier)${NC} — refresh token is invalid"
    done

    echo ""
    echo -e "  ${BOLD}${#STALE_CREDS[@]} credential(s) need a fresh login.${NC}"
    echo -e "  Each login opens a browser — log in with the matching account."
    echo ""
    read -rp "  Log in now? [Y/n] " answer

    if [[ "${answer:-Y}" =~ ^[Yy]$ ]]; then
        # Track which stale creds still need login (by index)
        declare -A stale_pending
        for f in "${STALE_CREDS[@]}"; do
            stale_pending["$f"]=1
        done

        # Back up current default so we can restore between logins
        backup_creds=$(mktemp)
        cp "$DEFAULT_CREDS" "$backup_creds" 2>/dev/null || true

        login_count=0
        while true; do
            # Find the next stale credential that still needs login
            next_stale=""
            for f in "${STALE_CREDS[@]}"; do
                if [ "${stale_pending[$f]:-}" = "1" ]; then
                    next_stale="$f"
                    break
                fi
            done

            # All done
            if [ -z "$next_stale" ]; then
                break
            fi

            next_name=$(basename "$next_stale")

            echo ""
            log "${BOLD}Log in with the account for:${NC} $next_name"

            # Remove .credentials.json so Claude starts without auth
            rm -f "$DEFAULT_CREDS"

            echo -e "  ${DIM}Type ${NC}/login${DIM} in Claude, complete browser auth, then ${NC}/exit${DIM} to return here.${NC}"
            echo ""

            # Launch Claude — without credentials it starts unauthenticated
            claude --dangerously-skip-permissions || true

            # Check if login produced a new credentials file
            if [ -f "$DEFAULT_CREDS" ]; then
                login_count=$((login_count + 1))

                # Trust the user — copy directly to the credential we asked them to log in for
                cp "$DEFAULT_CREDS" "$next_stale"
                stale_pending["$next_stale"]=0
                log_success "Updated $next_name with fresh token"
            else
                log_error "Login did not produce credentials"
                echo ""
                read -rp "  Try again? [Y/n] " retry_answer
                if [[ ! "${retry_answer:-Y}" =~ ^[Yy]$ ]]; then
                    # Mark this one as handled so we move on
                    stale_pending["$next_stale"]=0
                fi
            fi

            # Check if any stale creds remain
            any_remaining=false
            for f in "${STALE_CREDS[@]}"; do
                if [ "${stale_pending[$f]:-}" = "1" ]; then
                    any_remaining=true
                    break
                fi
            done

            if ! $any_remaining; then
                break
            fi

            echo ""
            read -rp "  Continue with next account? [Y/n] " cont_answer
            if [[ ! "${cont_answer:-Y}" =~ ^[Yy]$ ]]; then
                break
            fi
        done

        # Restore backup if login didn't produce a credentials file
        if [ ! -f "$DEFAULT_CREDS" ] && [ -f "$backup_creds" ]; then
            cp "$backup_creds" "$DEFAULT_CREDS"
        fi
        rm -f "$backup_creds"

        if [ "$login_count" -gt 0 ]; then
            log_success "Login complete — $login_count account(s) refreshed"
        fi
    else
        log "Skipping login — stale credentials will be deprioritized"
    fi
fi

# ── Step 5: Determine preferred credential ──────────────────────────────────

vlog_header "Determining priority"

PREFERRED_CRED=""

# Check for project-level credential preference in .claude/clad.json
LINKED_ACCOUNT=$(project_config_get credential)
if [ -n "$LINKED_ACCOUNT" ]; then
    linked_file="$CLAUDE_DIR/.credentials-${LINKED_ACCOUNT}.json"
    if [ -f "$linked_file" ]; then
        PREFERRED_CRED="$linked_file"
        vlog "Project preference → ${LINKED_ACCOUNT}"
    else
        log_warn "Linked credential '${LINKED_ACCOUNT}' not found — ignoring"
    fi
fi

# Fallback: match current default to a named file by refresh token
if [ -z "$PREFERRED_CRED" ] && [ -f "$DEFAULT_CREDS" ]; then
    default_refresh=$(jq -r '.claudeAiOauth.refreshToken // empty' "$DEFAULT_CREDS" 2>/dev/null)
    if [ -n "$default_refresh" ]; then
        for f in "${CRED_FILES[@]}"; do
            f_refresh=$(jq -r '.claudeAiOauth.refreshToken // empty' "$f" 2>/dev/null)
            if [ "$default_refresh" = "$f_refresh" ]; then
                PREFERRED_CRED="$f"
                vlog "Default matches $(basename "$f")"
                break
            fi
        done
    fi
fi

# Ultimate fallback: first named file
if [ -z "$PREFERRED_CRED" ]; then
    PREFERRED_CRED="${CRED_FILES[0]}"
    vlog "Default preference: $(basename "$PREFERRED_CRED")"
fi

# Build ordered list: preferred first, then others
ORDERED_CREDS=("$PREFERRED_CRED")
for f in "${CRED_FILES[@]}"; do
    [ "$f" != "$PREFERRED_CRED" ] && ORDERED_CREDS+=("$f")
done

# ── Step 6: Check rate limit usage ──────────────────────────────────────────

vlog_header "Checking rate limits"

# Queries rate limit usage via a minimal haiku call (1 output token).
# Claude Max uses unified rate limit headers with utilization values (0.0-1.0).
# The "representative claim" (5h or 7d) is the binding limit window.
# Returns usage percentage (0-100), or -1 on error.
get_usage_pct() {
    local cred_file="$1"
    local access_token
    access_token=$(jq -r '.claudeAiOauth.accessToken // empty' "$cred_file" 2>/dev/null)

    if [ -z "$access_token" ]; then
        echo "-1"
        return
    fi

    # Minimal haiku call — 1 output token, costs virtually nothing
    # Requires oauth beta header for Max subscription tokens
    local tmp_headers tmp_body http_code
    tmp_headers=$(mktemp)
    tmp_body=$(mktemp)

    http_code=$(curl -s -o "$tmp_body" -D "$tmp_headers" -w '%{http_code}' \
        -H "Authorization: Bearer $access_token" \
        -H "anthropic-version: 2023-06-01" \
        -H "anthropic-beta: oauth-2025-04-20" \
        -H "content-type: application/json" \
        -d '{"model":"claude-haiku-4-5-20251001","max_tokens":1,"messages":[{"role":"user","content":"x"}]}' \
        "$API_BASE/messages" 2>/dev/null) || true

    # 429 = rate limited
    if [ "$http_code" = "429" ]; then
        rm -f "$tmp_headers" "$tmp_body"
        echo "100"
        return
    fi

    # Auth failure
    if [ "$http_code" = "401" ] || [ "$http_code" = "403" ]; then
        rm -f "$tmp_headers" "$tmp_body"
        echo "-1"
        return
    fi

    # Parse unified rate limit headers (Claude Max format)
    # representative-claim tells us which window is binding (five_hour or seven_day)
    local claim util_5h util_7d
    claim=$(grep -i 'anthropic-ratelimit-unified-representative-claim' "$tmp_headers" 2>/dev/null | awk '{print $2}' | tr -d '\r\n' || true)
    util_5h=$(grep -i 'anthropic-ratelimit-unified-5h-utilization' "$tmp_headers" 2>/dev/null | awk '{print $2}' | tr -d '\r\n' || true)
    util_7d=$(grep -i 'anthropic-ratelimit-unified-7d-utilization' "$tmp_headers" 2>/dev/null | awk '{print $2}' | tr -d '\r\n' || true)

    rm -f "$tmp_headers" "$tmp_body"

    # Use the binding window's utilization, fall back to whichever is higher
    local util=""
    if [ "$claim" = "five_hour" ] && [ -n "$util_5h" ]; then
        util="$util_5h"
    elif [ "$claim" = "seven_day" ] && [ -n "$util_7d" ]; then
        util="$util_7d"
    elif [ -n "$util_7d" ]; then
        util="$util_7d"
    elif [ -n "$util_5h" ]; then
        util="$util_5h"
    fi

    if [ -n "$util" ]; then
        # Convert 0.0-1.0 float to 0-100 integer percentage
        local pct
        pct=$(awk "BEGIN { printf \"%.0f\", $util * 100 }")
        echo "$pct"
    elif [ "$http_code" = "200" ]; then
        echo "0"
    else
        echo "-1"
    fi
}

BEST_CRED=""
BEST_USAGE=101

for cred in "${ORDERED_CREDS[@]}"; do
    name=$(basename "$cred")
    vlog "Checking ${BOLD}$name${NC}..."

    # Skip if token is still expired (login was skipped or failed)
    if is_token_expired "$cred"; then
        vlog_warn "  Token still expired — skipping"
        continue
    fi

    usage=$(get_usage_pct "$cred")

    case "$usage" in
        -1)
            vlog_warn "  Could not determine usage"
            # Still a fallback candidate if nothing else works
            if [ -z "$BEST_CRED" ]; then
                BEST_CRED="$cred"
                BEST_USAGE=50
            fi
            continue
            ;;
        100)
            log_error "  Rate limited (100%)"
            ;;
        *)
            if [ "$usage" -lt 50 ]; then
                vlog_success "  ${usage}% used — plenty of capacity"
            elif [ "$usage" -lt 90 ]; then
                vlog_success "  ${usage}% used"
            else
                vlog_warn "  ${usage}% used — running low"
            fi
            ;;
    esac

    # Selection logic:
    # Preferred key with <99% usage → use immediately
    if [ "$cred" = "$PREFERRED_CRED" ] && [ "$usage" -lt 99 ]; then
        BEST_CRED="$cred"
        BEST_USAGE=$usage
        break
    fi

    # Any key with <90% usage → use immediately
    if [ "$usage" -lt 90 ]; then
        BEST_CRED="$cred"
        BEST_USAGE=$usage
        break
    fi

    # Track lowest usage as fallback
    if [ "$usage" -lt "$BEST_USAGE" ]; then
        BEST_CRED="$cred"
        BEST_USAGE=$usage
    fi
done

# ── Step 7: Select and activate ─────────────────────────────────────────────

vlog_header "Activating credential"

if [ -z "$BEST_CRED" ]; then
    BEST_CRED="$PREFERRED_CRED"
    log_warn "No usage data available — using preferred: $(basename "$BEST_CRED")"
elif [ "$BEST_USAGE" -ge 90 ]; then
    log_warn "All keys heavily used — best available: $(basename "$BEST_CRED") (${BEST_USAGE}%)"
else
    vlog_success "Selected: $(basename "$BEST_CRED") (${BEST_USAGE}% used)"
fi

# Warn if not using the preferred credential
if [ "$BEST_CRED" != "$PREFERRED_CRED" ]; then
    log_warn "Not using preferred $(basename "$PREFERRED_CRED") — switched to $(basename "$BEST_CRED")"
fi

# Copy selected credential to default location and record which was activated
cp "$BEST_CRED" "$DEFAULT_CREDS"
echo "$BEST_CRED" > "$ACTIVE_MARKER"
vlog_success "Credential activated"

# ── Step 8: Launch Claude ───────────────────────────────────────────────────

# Determine trust mode from project config (.claude/clad.json in cwd)
SELECTED_ACCOUNT=$(cred_to_account "$BEST_CRED")
PROJECT_TRUST=$(project_config_get trust)
PROJECT_TRUST="${PROJECT_TRUST:-false}"

LAUNCH_ARGS=()
if [ "$PROJECT_TRUST" = "true" ]; then
    LAUNCH_ARGS+=(--dangerously-skip-permissions)
fi

echo ""
if [ "$PROJECT_TRUST" = "true" ]; then
    log_success "${BOLD}Launching Claude Code${NC} ${DIM}(${SELECTED_ACCOUNT}, trusted, ${BEST_USAGE}% used)${NC}"
else
    log_success "${BOLD}Launching Claude Code${NC} ${DIM}(${SELECTED_ACCOUNT}, ${BEST_USAGE}% used)${NC}"
fi
echo ""

exec claude "${LAUNCH_ARGS[@]}" "${CLAUDE_ARGS[@]}"
