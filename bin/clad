#!/bin/bash
#
# clad - Claude with Automatic credential Detection
#
# Selects the best available Claude credential based on rate limit usage,
# then launches Claude Code in dangerous mode.
#
# Credential priority:
#   1. Project-level .claude-credentials.json symlink (if present in cwd)
#   2. Default ~/.claude/.credentials.json
#   3. All other ~/.claude/.credentials-*.json files
#
# Selection algorithm:
#   - Check preferred key first. If <99% used, keep it.
#   - If >=99%, cycle through remaining keys.
#   - First key found with <90% usage wins.
#   - If all >=90%, use the key with lowest usage.

set -euo pipefail

CLAUDE_DIR="$HOME/.claude"
DEFAULT_CREDS="$CLAUDE_DIR/.credentials.json"
OAUTH_CLIENT_ID="9d1c250a-e61b-44d9-88ed-5944d1962f5e"
OAUTH_TOKEN_URL="https://console.anthropic.com/v1/oauth/token"
API_BASE="https://api.anthropic.com/v1"

# ── Colors ──────────────────────────────────────────────────────────────────

GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

log()         { echo -e "  ${BLUE}▸${NC} $1"; }
log_success() { echo -e "  ${GREEN}✓${NC} $1"; }
log_warn()    { echo -e "  ${YELLOW}⚠${NC} $1"; }
log_error()   { echo -e "  ${RED}✗${NC} $1"; }
log_header()  { echo -e "\n${CYAN}${BOLD}── $1 ──${NC}"; }

# ── Dependency check ────────────────────────────────────────────────────────

for cmd in jq curl claude; do
    if ! command -v "$cmd" &>/dev/null; then
        log_error "Required command '${BOLD}$cmd${NC}' not found"
        exit 1
    fi
done

# ── Helper: check if a credential's access token is expired ─────────────────

is_token_expired() {
    local cred_file="$1"
    local expires_at now_ms
    expires_at=$(jq -r '.claudeAiOauth.expiresAt // 0' "$cred_file" 2>/dev/null)
    now_ms=$(( $(date +%s) * 1000 ))
    [ "$expires_at" -gt 0 ] 2>/dev/null && [ "$expires_at" -lt "$now_ms" ] 2>/dev/null
}

# ── Helper: get the friendly label for a credential file ────────────────────

cred_label() {
    local cred_file="$1"
    local name tier
    name=$(basename "$cred_file")
    tier=$(jq -r '.claudeAiOauth.rateLimitTier // "unknown"' "$cred_file" 2>/dev/null)
    echo "$name ${DIM}($tier)${NC}"
}

# ── Token refresh ───────────────────────────────────────────────────────────

# Refreshes an expired OAuth token via the refresh_token grant.
# Updates the credential file in place. Returns 0 on success, 1 on failure.
refresh_token() {
    local cred_file="$1"
    local refresh_tok
    refresh_tok=$(jq -r '.claudeAiOauth.refreshToken // empty' "$cred_file" 2>/dev/null)

    if [ -z "$refresh_tok" ]; then
        return 1
    fi

    local response
    response=$(curl -s -X POST "$OAUTH_TOKEN_URL" \
        -H "Content-Type: application/json" \
        -d "{\"grant_type\":\"refresh_token\",\"refresh_token\":\"$refresh_tok\",\"client_id\":\"$OAUTH_CLIENT_ID\"}" \
        2>/dev/null) || return 1

    # Check for error response
    local err_type err_msg
    err_type=$(echo "$response" | jq -r '.error // empty' 2>/dev/null)
    err_msg=$(echo "$response" | jq -r '.error_description // .message // empty' 2>/dev/null)
    if [ -n "$err_type" ]; then
        log_error "  Refresh error: ${err_type}${err_msg:+ — $err_msg}"
        return 1
    fi

    # Empty or non-JSON response
    if [ -z "$response" ] || ! echo "$response" | jq -e '.' &>/dev/null; then
        log_error "  Refresh returned invalid response"
        return 1
    fi

    # Extract new tokens
    local new_access new_refresh expires_in
    new_access=$(echo "$response" | jq -r '.access_token // empty')
    new_refresh=$(echo "$response" | jq -r '.refresh_token // empty')
    expires_in=$(echo "$response" | jq -r '.expires_in // 0')

    if [ -z "$new_access" ] || [ -z "$new_refresh" ]; then
        return 1
    fi

    # Calculate expiresAt in milliseconds
    local now_ms expires_at
    now_ms=$(( $(date +%s) * 1000 ))
    expires_at=$(( now_ms + (expires_in * 1000) ))

    # Update the credential file, preserving all other fields
    local updated
    updated=$(jq \
        --arg at "$new_access" \
        --arg rt "$new_refresh" \
        --argjson ea "$expires_at" \
        '.claudeAiOauth.accessToken = $at | .claudeAiOauth.refreshToken = $rt | .claudeAiOauth.expiresAt = $ea' \
        "$cred_file")

    echo "$updated" > "$cred_file"
    return 0
}

# ── Step 1: Discover credential files ───────────────────────────────────────

log_header "Discovering credentials"

CRED_FILES=()
for f in "$CLAUDE_DIR"/.credentials-*.json; do
    [ -f "$f" ] && CRED_FILES+=("$f")
done

if [ ${#CRED_FILES[@]} -eq 0 ]; then
    log_warn "No alternate credential files found"
    log "Launching with default credentials..."
    exec claude --dangerously-skip-permissions "$@"
fi

for f in "${CRED_FILES[@]}"; do
    log "Found $(cred_label "$f")"
done

# ── Step 2: Sync back refreshed tokens from .credentials.json ───────────────

# Claude Code refreshes the token in .credentials.json on launch, but the
# named credential files become stale. Match by rateLimitTier (stable account
# identifier) and sync if the default has a newer expiresAt.
if [ -f "$DEFAULT_CREDS" ]; then
    default_tier=$(jq -r '.claudeAiOauth.rateLimitTier // empty' "$DEFAULT_CREDS" 2>/dev/null)
    default_expires=$(jq -r '.claudeAiOauth.expiresAt // 0' "$DEFAULT_CREDS" 2>/dev/null)

    if [ -n "$default_tier" ]; then
        for f in "${CRED_FILES[@]}"; do
            f_tier=$(jq -r '.claudeAiOauth.rateLimitTier // empty' "$f" 2>/dev/null)
            f_expires=$(jq -r '.claudeAiOauth.expiresAt // 0' "$f" 2>/dev/null)

            if [ "$f_tier" = "$default_tier" ] && [ "$default_expires" -gt "$f_expires" ] 2>/dev/null; then
                cp "$DEFAULT_CREDS" "$f"
                log_success "Synced refreshed token → $(basename "$f")"
            fi
        done
    fi
fi

# ── Step 3: Refresh expired tokens ─────────────────────────────────────────

STALE_CREDS=()

for f in "${CRED_FILES[@]}"; do
    if is_token_expired "$f"; then
        log "$(basename "$f") expired, attempting refresh..."
        if refresh_token "$f"; then
            log_success "  Refreshed successfully"
        else
            STALE_CREDS+=("$f")
        fi
    fi
done

# ── Step 4: Interactive login for irrecoverable tokens ──────────────────────

if [ ${#STALE_CREDS[@]} -gt 0 ]; then
    log_header "Credentials need re-login"

    for f in "${STALE_CREDS[@]}"; do
        tier=$(jq -r '.claudeAiOauth.rateLimitTier // "unknown"' "$f" 2>/dev/null)
        log_warn "$(basename "$f") ${DIM}($tier)${NC} — refresh token is invalid"
    done

    echo ""
    echo -e "  ${BOLD}${#STALE_CREDS[@]} credential(s) need a fresh login.${NC}"
    echo -e "  Each login opens a browser — log in with the matching account."
    echo ""
    read -rp "  Log in now? [Y/n] " answer

    if [[ "${answer:-Y}" =~ ^[Yy]$ ]]; then
        # Track which stale creds still need login (by index)
        declare -A stale_pending
        for f in "${STALE_CREDS[@]}"; do
            stale_pending["$f"]=1
        done

        # Back up current default so we can restore between logins
        backup_creds=$(mktemp)
        cp "$DEFAULT_CREDS" "$backup_creds" 2>/dev/null || true

        login_count=0
        while true; do
            # Find the next stale credential that still needs login
            next_stale=""
            for f in "${STALE_CREDS[@]}"; do
                if [ "${stale_pending[$f]:-}" = "1" ]; then
                    next_stale="$f"
                    break
                fi
            done

            # All done
            if [ -z "$next_stale" ]; then
                break
            fi

            next_tier=$(jq -r '.claudeAiOauth.rateLimitTier // "unknown"' "$next_stale" 2>/dev/null)
            next_name=$(basename "$next_stale")

            echo ""
            log "${BOLD}Log in with the account for:${NC} $next_name ${DIM}($next_tier)${NC}"
            echo ""

            # Run claude login (interactive — opens browser)
            if claude login; then
                login_count=$((login_count + 1))

                # Read the new token's tier from .credentials.json
                new_tier=$(jq -r '.claudeAiOauth.rateLimitTier // empty' "$DEFAULT_CREDS" 2>/dev/null)

                if [ -n "$new_tier" ]; then
                    # Match to any stale credential with this tier
                    matched=false
                    for f in "${STALE_CREDS[@]}"; do
                        f_tier=$(jq -r '.claudeAiOauth.rateLimitTier // empty' "$f" 2>/dev/null)
                        if [ "$f_tier" = "$new_tier" ] && [ "${stale_pending[$f]:-}" = "1" ]; then
                            cp "$DEFAULT_CREDS" "$f"
                            stale_pending["$f"]=0
                            log_success "Updated $(basename "$f") with fresh token"
                            matched=true
                            break
                        fi
                    done

                    if ! $matched; then
                        log_warn "Logged in with tier '$new_tier' — doesn't match any stale credential"
                        log_warn "Expected one of: $next_tier"
                    fi
                else
                    log_warn "Could not read tier from new login"
                fi
            else
                log_error "Login failed or cancelled"
                echo ""
                read -rp "  Skip remaining logins? [Y/n] " skip_answer
                if [[ "${skip_answer:-Y}" =~ ^[Yy]$ ]]; then
                    break
                fi
            fi

            # Check if any stale creds remain
            any_remaining=false
            for f in "${STALE_CREDS[@]}"; do
                if [ "${stale_pending[$f]:-}" = "1" ]; then
                    any_remaining=true
                    break
                fi
            done

            if ! $any_remaining; then
                break
            fi
        done

        # Restore the backup so we don't accidentally leave the wrong account active
        # (the usage check below will pick the right one)
        if [ -f "$backup_creds" ]; then
            cp "$backup_creds" "$DEFAULT_CREDS"
            rm -f "$backup_creds"
        fi

        if [ "$login_count" -gt 0 ]; then
            log_success "Login complete — $login_count account(s) refreshed"
        fi
    else
        log "Skipping login — stale credentials will be deprioritized"
    fi
fi

# ── Step 5: Determine preferred credential ──────────────────────────────────

log_header "Determining priority"

PREFERRED_CRED=""

# Check for project-level symlink/file in current directory
if [ -e ".claude-credentials.json" ]; then
    target=$(readlink -f ".claude-credentials.json" 2>/dev/null || realpath ".claude-credentials.json" 2>/dev/null)
    if [ -f "$target" ]; then
        PREFERRED_CRED="$target"
        if [ -L ".claude-credentials.json" ]; then
            log "Project symlink → $(basename "$target")"
        else
            log "Project credential: $(basename "$target")"
        fi
    fi
fi

# Fallback: match current default to a named file by refresh token
if [ -z "$PREFERRED_CRED" ] && [ -f "$DEFAULT_CREDS" ]; then
    default_refresh=$(jq -r '.claudeAiOauth.refreshToken // empty' "$DEFAULT_CREDS" 2>/dev/null)
    if [ -n "$default_refresh" ]; then
        for f in "${CRED_FILES[@]}"; do
            f_refresh=$(jq -r '.claudeAiOauth.refreshToken // empty' "$f" 2>/dev/null)
            if [ "$default_refresh" = "$f_refresh" ]; then
                PREFERRED_CRED="$f"
                log "Default matches $(basename "$f")"
                break
            fi
        done
    fi
fi

# Ultimate fallback: first named file
if [ -z "$PREFERRED_CRED" ]; then
    PREFERRED_CRED="${CRED_FILES[0]}"
    log "Default preference: $(basename "$PREFERRED_CRED")"
fi

# Build ordered list: preferred first, then others
ORDERED_CREDS=("$PREFERRED_CRED")
for f in "${CRED_FILES[@]}"; do
    [ "$f" != "$PREFERRED_CRED" ] && ORDERED_CREDS+=("$f")
done

# ── Step 6: Check rate limit usage ──────────────────────────────────────────

log_header "Checking rate limits"

# Queries rate limit usage via the count_tokens endpoint (free, no inference).
# Returns usage percentage (0-100), or -1 on error.
get_usage_pct() {
    local cred_file="$1"
    local access_token
    access_token=$(jq -r '.claudeAiOauth.accessToken // empty' "$cred_file" 2>/dev/null)

    if [ -z "$access_token" ]; then
        echo "-1"
        return
    fi

    # Use count_tokens endpoint — free, no LLM inference
    local tmp_headers tmp_body http_code
    tmp_headers=$(mktemp)
    tmp_body=$(mktemp)

    http_code=$(curl -s -o "$tmp_body" -D "$tmp_headers" -w '%{http_code}' \
        -H "Authorization: Bearer $access_token" \
        -H "anthropic-version: 2023-06-01" \
        -H "content-type: application/json" \
        -d '{"model":"claude-haiku-4-5-20251001","messages":[{"role":"user","content":"x"}]}' \
        "$API_BASE/messages/count_tokens" 2>/dev/null) || true

    # 429 = rate limited
    if [ "$http_code" = "429" ]; then
        rm -f "$tmp_headers" "$tmp_body"
        echo "100"
        return
    fi

    # Auth failure
    if [ "$http_code" = "401" ] || [ "$http_code" = "403" ]; then
        rm -f "$tmp_headers" "$tmp_body"
        echo "-1"
        return
    fi

    # Parse rate limit headers
    local remaining limit
    remaining=$(grep -i 'anthropic-ratelimit-tokens-remaining' "$tmp_headers" 2>/dev/null | awk '{print $2}' | tr -d '\r\n' || true)
    limit=$(grep -i 'anthropic-ratelimit-tokens-limit' "$tmp_headers" 2>/dev/null | awk '{print $2}' | tr -d '\r\n' || true)

    rm -f "$tmp_headers" "$tmp_body"

    if [ -n "$remaining" ] && [ -n "$limit" ] && [ "$limit" -gt 0 ] 2>/dev/null; then
        local used pct
        used=$((limit - remaining))
        if [ "$used" -lt 0 ]; then used=0; fi
        pct=$((used * 100 / limit))
        echo "$pct"
    elif [ "$http_code" = "200" ]; then
        # API succeeded but no rate limit headers — assume fine
        echo "0"
    else
        echo "-1"
    fi
}

BEST_CRED=""
BEST_USAGE=101

for cred in "${ORDERED_CREDS[@]}"; do
    name=$(basename "$cred")
    log "Checking ${BOLD}$name${NC}..."

    # Skip if token is still expired (login was skipped or failed)
    if is_token_expired "$cred"; then
        log_warn "  Token still expired — skipping"
        continue
    fi

    usage=$(get_usage_pct "$cred")

    case "$usage" in
        -1)
            log_warn "  Could not determine usage"
            # Still a fallback candidate if nothing else works
            if [ -z "$BEST_CRED" ]; then
                BEST_CRED="$cred"
                BEST_USAGE=50
            fi
            continue
            ;;
        100)
            log_error "  Rate limited (100%)"
            ;;
        *)
            if [ "$usage" -lt 50 ]; then
                log_success "  ${usage}% used — plenty of capacity"
            elif [ "$usage" -lt 90 ]; then
                log_success "  ${usage}% used"
            else
                log_warn "  ${usage}% used — running low"
            fi
            ;;
    esac

    # Selection logic:
    # Preferred key with <99% usage → use immediately
    if [ "$cred" = "$PREFERRED_CRED" ] && [ "$usage" -lt 99 ]; then
        BEST_CRED="$cred"
        BEST_USAGE=$usage
        break
    fi

    # Any key with <90% usage → use immediately
    if [ "$usage" -lt 90 ]; then
        BEST_CRED="$cred"
        BEST_USAGE=$usage
        break
    fi

    # Track lowest usage as fallback
    if [ "$usage" -lt "$BEST_USAGE" ]; then
        BEST_CRED="$cred"
        BEST_USAGE=$usage
    fi
done

# ── Step 7: Select and activate ─────────────────────────────────────────────

log_header "Activating credential"

if [ -z "$BEST_CRED" ]; then
    BEST_CRED="$PREFERRED_CRED"
    log_warn "No usage data available — using preferred: $(basename "$BEST_CRED")"
elif [ "$BEST_USAGE" -ge 90 ]; then
    log_warn "All keys heavily used — best available: $(basename "$BEST_CRED") (${BEST_USAGE}%)"
else
    log_success "Selected: $(basename "$BEST_CRED") (${BEST_USAGE}% used)"
fi

# Copy selected credential to default location
cp "$BEST_CRED" "$DEFAULT_CREDS"
log_success "Credential activated"

# ── Step 8: Launch Claude ───────────────────────────────────────────────────

echo ""
log_success "${BOLD}Launching Claude Code${NC}"
echo ""

exec claude --dangerously-skip-permissions "$@"
