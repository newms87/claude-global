#!/bin/bash
#
# clad - Claude with Automatic credential Detection
#
# Selects the best available Claude credential based on rate limit usage,
# then launches Claude Code in dangerous mode.
#
# Credential priority:
#   1. Project-level .claude-credentials.json symlink (if present in cwd)
#   2. Default ~/.claude/.credentials.json
#   3. All other ~/.claude/.credentials-*.json files
#
# Selection algorithm:
#   - Check preferred key first. If <99% used, keep it.
#   - If >=99%, cycle through remaining keys.
#   - First key found with <90% usage wins.
#   - If all >=90%, use the key with lowest usage.

set -euo pipefail

CLAUDE_DIR="$HOME/.claude"
DEFAULT_CREDS="$CLAUDE_DIR/.credentials.json"
OAUTH_CLIENT_ID="9d1c250a-e61b-44d9-88ed-5944d1962f5e"
OAUTH_TOKEN_URL="https://console.anthropic.com/v1/oauth/token"
API_BASE="https://api.anthropic.com/v1"

# ── Colors ──────────────────────────────────────────────────────────────────

GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

log()         { echo -e "  ${BLUE}▸${NC} $1"; }
log_success() { echo -e "  ${GREEN}✓${NC} $1"; }
log_warn()    { echo -e "  ${YELLOW}⚠${NC} $1"; }
log_error()   { echo -e "  ${RED}✗${NC} $1"; }
log_header()  { echo -e "\n${CYAN}${BOLD}── $1 ──${NC}"; }

# ── Dependency check ────────────────────────────────────────────────────────

for cmd in jq curl claude; do
    if ! command -v "$cmd" &>/dev/null; then
        log_error "Required command '${BOLD}$cmd${NC}' not found"
        exit 1
    fi
done

# ── Token refresh ───────────────────────────────────────────────────────────

# Refreshes an expired OAuth token. Updates the credential file in place.
# Returns 0 on success, 1 on failure.
refresh_token() {
    local cred_file="$1"
    local refresh_token
    refresh_token=$(jq -r '.claudeAiOauth.refreshToken // empty' "$cred_file" 2>/dev/null)

    if [ -z "$refresh_token" ]; then
        return 1
    fi

    local response
    response=$(curl -s -X POST "$OAUTH_TOKEN_URL" \
        -H "Content-Type: application/json" \
        -d "{\"grant_type\":\"refresh_token\",\"refresh_token\":\"$refresh_token\",\"client_id\":\"$OAUTH_CLIENT_ID\"}" \
        2>/dev/null) || return 1

    # Check for error response
    if echo "$response" | jq -e '.error' &>/dev/null; then
        return 1
    fi

    # Extract new tokens
    local new_access new_refresh expires_in
    new_access=$(echo "$response" | jq -r '.access_token // empty')
    new_refresh=$(echo "$response" | jq -r '.refresh_token // empty')
    expires_in=$(echo "$response" | jq -r '.expires_in // 0')

    if [ -z "$new_access" ] || [ -z "$new_refresh" ]; then
        return 1
    fi

    # Calculate expiresAt in milliseconds
    local now_ms expires_at
    now_ms=$(( $(date +%s) * 1000 ))
    expires_at=$(( now_ms + (expires_in * 1000) ))

    # Update the credential file, preserving all other fields
    local updated
    updated=$(jq \
        --arg at "$new_access" \
        --arg rt "$new_refresh" \
        --argjson ea "$expires_at" \
        '.claudeAiOauth.accessToken = $at | .claudeAiOauth.refreshToken = $rt | .claudeAiOauth.expiresAt = $ea' \
        "$cred_file")

    echo "$updated" > "$cred_file"
    return 0
}

# ── Step 1: Discover credential files ───────────────────────────────────────

log_header "Discovering credentials"

CRED_FILES=()
for f in "$CLAUDE_DIR"/.credentials-*.json; do
    [ -f "$f" ] && CRED_FILES+=("$f")
done

if [ ${#CRED_FILES[@]} -eq 0 ]; then
    log_warn "No alternate credential files found"
    log "Launching with default credentials..."
    exec claude --dangerously-skip-permissions "$@"
fi

for f in "${CRED_FILES[@]}"; do
    tier=$(jq -r '.claudeAiOauth.rateLimitTier // "unknown"' "$f" 2>/dev/null)
    log "Found $(basename "$f") ${DIM}($tier)${NC}"
done

# ── Step 2: Determine preferred credential ──────────────────────────────────

log_header "Determining priority"

PREFERRED_CRED=""

# Check for project-level symlink/file in current directory
if [ -e ".claude-credentials.json" ]; then
    target=$(readlink -f ".claude-credentials.json" 2>/dev/null || realpath ".claude-credentials.json" 2>/dev/null)
    if [ -f "$target" ]; then
        PREFERRED_CRED="$target"
        if [ -L ".claude-credentials.json" ]; then
            log "Project symlink → $(basename "$target")"
        else
            log "Project credential: $(basename "$target")"
        fi
    fi
fi

# Fallback: match current default to a named file by refresh token
if [ -z "$PREFERRED_CRED" ] && [ -f "$DEFAULT_CREDS" ]; then
    default_refresh=$(jq -r '.claudeAiOauth.refreshToken // empty' "$DEFAULT_CREDS" 2>/dev/null)
    if [ -n "$default_refresh" ]; then
        for f in "${CRED_FILES[@]}"; do
            f_refresh=$(jq -r '.claudeAiOauth.refreshToken // empty' "$f" 2>/dev/null)
            if [ "$default_refresh" = "$f_refresh" ]; then
                PREFERRED_CRED="$f"
                log "Default matches $(basename "$f")"
                break
            fi
        done
    fi
fi

# Ultimate fallback: first named file
if [ -z "$PREFERRED_CRED" ]; then
    PREFERRED_CRED="${CRED_FILES[0]}"
    log "Default preference: $(basename "$PREFERRED_CRED")"
fi

# Build ordered list: preferred first, then others
ORDERED_CREDS=("$PREFERRED_CRED")
for f in "${CRED_FILES[@]}"; do
    [ "$f" != "$PREFERRED_CRED" ] && ORDERED_CREDS+=("$f")
done

# ── Step 3: Check rate limit usage ──────────────────────────────────────────

log_header "Checking rate limits"

# Ensures the credential file has a valid (non-expired) access token.
# Refreshes if expired. Returns 0 if token is valid, 1 if refresh failed.
ensure_valid_token() {
    local cred_file="$1"
    local expires_at now_ms
    expires_at=$(jq -r '.claudeAiOauth.expiresAt // 0' "$cred_file" 2>/dev/null)
    now_ms=$(( $(date +%s) * 1000 ))

    if [ "$expires_at" -gt 0 ] 2>/dev/null && [ "$expires_at" -lt "$now_ms" ] 2>/dev/null; then
        log "  Token expired, refreshing..."
        if refresh_token "$cred_file"; then
            log_success "  Token refreshed"
            return 0
        else
            log_error "  Refresh failed — needs re-login"
            return 1
        fi
    fi
    return 0
}

# Queries rate limit usage via the count_tokens endpoint (free, no inference).
# Returns usage percentage (0-100), or -1 on error.
get_usage_pct() {
    local cred_file="$1"
    local access_token
    access_token=$(jq -r '.claudeAiOauth.accessToken // empty' "$cred_file" 2>/dev/null)

    if [ -z "$access_token" ]; then
        echo "-1"
        return
    fi

    # Use count_tokens endpoint — free, no LLM inference
    local tmp_headers tmp_body http_code
    tmp_headers=$(mktemp)
    tmp_body=$(mktemp)

    http_code=$(curl -s -o "$tmp_body" -D "$tmp_headers" -w '%{http_code}' \
        -H "Authorization: Bearer $access_token" \
        -H "anthropic-version: 2023-06-01" \
        -H "content-type: application/json" \
        -d '{"model":"claude-haiku-4-5-20251001","messages":[{"role":"user","content":"x"}]}' \
        "$API_BASE/messages/count_tokens" 2>/dev/null) || true

    # 429 = rate limited
    if [ "$http_code" = "429" ]; then
        rm -f "$tmp_headers" "$tmp_body"
        echo "100"
        return
    fi

    # Auth failure even after refresh
    if [ "$http_code" = "401" ] || [ "$http_code" = "403" ]; then
        rm -f "$tmp_headers" "$tmp_body"
        echo "-1"
        return
    fi

    # Parse rate limit headers
    local remaining limit
    remaining=$(grep -i 'anthropic-ratelimit-tokens-remaining' "$tmp_headers" 2>/dev/null | awk '{print $2}' | tr -d '\r\n' || true)
    limit=$(grep -i 'anthropic-ratelimit-tokens-limit' "$tmp_headers" 2>/dev/null | awk '{print $2}' | tr -d '\r\n' || true)

    rm -f "$tmp_headers" "$tmp_body"

    if [ -n "$remaining" ] && [ -n "$limit" ] && [ "$limit" -gt 0 ] 2>/dev/null; then
        local used pct
        used=$((limit - remaining))
        if [ "$used" -lt 0 ]; then used=0; fi
        pct=$((used * 100 / limit))
        echo "$pct"
    elif [ "$http_code" = "200" ]; then
        # API succeeded but no rate limit headers — assume fine
        echo "0"
    else
        echo "-1"
    fi
}

BEST_CRED=""
BEST_USAGE=101

for cred in "${ORDERED_CREDS[@]}"; do
    name=$(basename "$cred")
    log "Checking ${BOLD}$name${NC}..."

    # Ensure token is valid (refresh if expired)
    if ! ensure_valid_token "$cred"; then
        log_warn "  Skipping — token invalid"
        continue
    fi

    usage=$(get_usage_pct "$cred")

    case "$usage" in
        -1)
            log_warn "  Could not determine usage"
            # Still a fallback candidate if nothing else works
            if [ -z "$BEST_CRED" ]; then
                BEST_CRED="$cred"
                BEST_USAGE=50
            fi
            continue
            ;;
        100)
            log_error "  Rate limited (100%)"
            ;;
        *)
            if [ "$usage" -lt 50 ]; then
                log_success "  ${usage}% used — plenty of capacity"
            elif [ "$usage" -lt 90 ]; then
                log_success "  ${usage}% used"
            else
                log_warn "  ${usage}% used — running low"
            fi
            ;;
    esac

    # Selection logic:
    # Preferred key with <99% usage → use immediately
    if [ "$cred" = "$PREFERRED_CRED" ] && [ "$usage" -lt 99 ]; then
        BEST_CRED="$cred"
        BEST_USAGE=$usage
        break
    fi

    # Any key with <90% usage → use immediately
    if [ "$usage" -lt 90 ]; then
        BEST_CRED="$cred"
        BEST_USAGE=$usage
        break
    fi

    # Track lowest usage as fallback
    if [ "$usage" -lt "$BEST_USAGE" ]; then
        BEST_CRED="$cred"
        BEST_USAGE=$usage
    fi
done

# ── Step 4: Select and activate ─────────────────────────────────────────────

log_header "Activating credential"

if [ -z "$BEST_CRED" ]; then
    BEST_CRED="$PREFERRED_CRED"
    log_warn "No usage data available — using preferred: $(basename "$BEST_CRED")"
elif [ "$BEST_USAGE" -ge 90 ]; then
    log_warn "All keys heavily used — best available: $(basename "$BEST_CRED") (${BEST_USAGE}%)"
else
    log_success "Selected: $(basename "$BEST_CRED") (${BEST_USAGE}% used)"
fi

# Copy selected credential to default location
cp "$BEST_CRED" "$DEFAULT_CREDS"
log_success "Credential activated"

# ── Step 5: Launch Claude ───────────────────────────────────────────────────

echo ""
log_success "${BOLD}Launching Claude Code${NC}"
echo ""

exec claude --dangerously-skip-permissions "$@"
